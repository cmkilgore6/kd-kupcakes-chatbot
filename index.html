import React, { useState, useEffect, useRef } from 'react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'firebase/auth';
import { getFirestore, collection, query, orderBy, limit, onSnapshot, addDoc, serverTimestamp, setLogLevel } from 'firebase/firestore';

// Set Firebase log level to Debug for visibility
setLogLevel('Debug');

// Global variables provided by the Canvas environment
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

const API_MODEL = 'gemini-2.5-flash-preview-09-2025';
const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${API_MODEL}:generateContent?key=`; // API key is provided at runtime

const App = () => {
  const [messages, setMessages] = useState([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [db, setDb] = useState(null);
  const [auth, setAuth] = useState(null);
  const [userId, setUserId] = useState(null);
  const [isAuthReady, setIsAuthReady] = useState(false);

  const messagesEndRef = useRef(null);

  // --- Firebase Initialization and Authentication ---
  useEffect(() => {
    try {
      const app = initializeApp(firebaseConfig);
      const firestore = getFirestore(app);
      const authInstance = getAuth(app);
      setDb(firestore);
      setAuth(authInstance);

      onAuthStateChanged(authInstance, (user) => {
        if (user) {
          setUserId(user.uid);
        } else {
          // If sign-in fails or user signs out, sign in anonymously as a fallback
          signInAnonymously(authInstance).then(anonUser => {
            setUserId(anonUser.user.uid);
          }).catch(error => {
            console.error("Anonymous sign-in failed:", error);
          });
        }
        setIsAuthReady(true);
      });

      // Attempt to sign in with the provided custom token
      if (initialAuthToken) {
        signInWithCustomToken(authInstance, initialAuthToken)
          .catch((error) => {
            console.error("Custom token sign-in failed. Falling back to anonymous.", error);
          });
      } else {
         // Fallback to anonymous sign-in if no custom token is provided
         signInAnonymously(authInstance)
          .catch((error) => {
            console.error("Anonymous sign-in failed:", error);
          });
      }
    } catch (e) {
      console.error("Firebase Initialization Error:", e);
    }
  }, []);

  // --- Firestore Listener for Messages ---
  useEffect(() => {
    // Only proceed once authentication is ready and we have a userId
    if (!isAuthReady || !db || !userId) return;

    // Use a public collection for a shared chatbot history
    const collectionPath = `artifacts/${appId}/public/data/kupcakes_chat`;
    const messagesCollection = collection(db, collectionPath);
    
    // Query to get the last 50 messages, ordered by creation time
    const q = query(messagesCollection, orderBy('timestamp', 'asc'), limit(50));

    const unsubscribe = onSnapshot(q, (snapshot) => {
      const newMessages = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        // Ensure timestamp is a Date object for reliable sorting/display
        timestamp: doc.data().timestamp?.toDate(),
      }));
      setMessages(newMessages);
      
      // Ensure the scroll is at the bottom after updating messages
      setTimeout(scrollToBottom, 10);
    }, (error) => {
      console.error("Error fetching messages from Firestore:", error);
    });

    return () => unsubscribe();
  }, [db, isAuthReady, userId]);

  // --- Auto-Scroll Function ---
  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  // --- Gemini API Call Function ---
  const sendMessageToGemini = async (chatHistory) => {
    const systemPrompt = "You are Sprinkles, the friendly and cheerful AI Chatbot for K's Kupcakes. You specialize in discussing flavors, ingredients, custom orders, and bakery opening hours (Mon-Sat, 9am-6pm). Keep your responses concise, helpful, and in a fun, upbeat tone, occasionally using food-related puns.";

    const payload = {
      contents: chatHistory,
      systemInstruction: {
        parts: [{ text: systemPrompt }]
      },
      tools: [{ "google_search": {} }], // Use Google Search for up-to-date info
    };

    const maxRetries = 3;
    let delay = 1000;

    for (let i = 0; i < maxRetries; i++) {
      try {
        const response = await fetch(API_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        if (!response.ok) {
          throw new Error(`API returned status ${response.status}`);
        }

        const result = await response.json();
        const text = result.candidates?.[0]?.content?.parts?.[0]?.text || "Sorry, I had a little baking mishap and couldn't process that. Try again!";
        
        return { success: true, text };

      } catch (error) {
        if (i < maxRetries - 1) {
          // Retry with exponential backoff
          await new Promise(resolve => setTimeout(resolve, delay));
          delay *= 2;
        } else {
          console.error("Final API call failed:", error);
          return { success: false, text: "My whisk broke! I can't talk right now. Please try again later." };
        }
      }
    }
  };


  // --- Send Message Handler ---
  const handleSend = async (e) => {
    e.preventDefault();
    if (!input.trim() || !db || !userId || isLoading) return;

    const userMessage = input.trim();
    setInput('');
    setIsLoading(true);
    
    // 1. Add User Message to Firestore
    try {
      const collectionRef = collection(db, `artifacts/${appId}/public/data/kupcakes_chat`);
      await addDoc(collectionRef, {
        text: userMessage,
        role: 'user',
        userId: userId,
        timestamp: serverTimestamp(),
      });
    } catch (error) {
      console.error("Error adding user message to Firestore:", error);
      setIsLoading(false);
      return;
    }

    // 2. Prepare chat history for Gemini (max 10 recent messages for context)
    const chatHistory = messages.slice(-9).map(msg => ({
      role: msg.role === 'user' ? 'user' : 'model',
      parts: [{ text: msg.text }]
    }));
    // Add current user message
    chatHistory.push({ role: 'user', parts: [{ text: userMessage }] });

    // 3. Get response from Gemini
    const geminiResponse = await sendMessageToGemini(chatHistory);

    // 4. Add Model Response to Firestore
    if (geminiResponse.success) {
      try {
        const collectionRef = collection(db, `artifacts/${appId}/public/data/kupcakes_chat`);
        await addDoc(collectionRef, {
          text: geminiResponse.text,
          role: 'model',
          userId: 'Sprinkles', // Bot's ID
          timestamp: serverTimestamp(),
        });
      } catch (error) {
        console.error("Error adding model message to Firestore:", error);
      }
    }
    
    setIsLoading(false);
  };

  // --- Message Bubble Component ---
  const MessageBubble = ({ message }) => {
    const isUser = message.role === 'user';
    const isSprinkles = message.role === 'model';
    const senderId = isSprinkles ? 'Sprinkles' : (message.userId === userId ? 'You' : message.userId.substring(0, 8) + '...');

    return (
      <div className={`flex mb-4 ${isUser ? 'justify-end' : 'justify-start'}`}>
        <div 
          className={`max-w-xs sm:max-w-md lg:max-w-lg px-4 py-3 rounded-xl shadow-md ${
            isUser 
              ? 'bg-pink-500 text-white rounded-br-none' 
              : 'bg-white text-gray-800 rounded-tl-none border border-gray-100'
          } transition-all duration-300 ease-in-out`}
          style={{ minWidth: '100px' }}
        >
          <div className={`text-xs font-semibold mb-1 ${isUser ? 'text-pink-100' : 'text-pink-600'}`}>
            {senderId}
          </div>
          <p className="text-sm break-words whitespace-pre-wrap">{message.text}</p>
          <div className="text-right text-xs mt-1 opacity-60">
            {message.timestamp ? new Date(message.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '...'}
          </div>
        </div>
      </div>
    );
  };
  
  // --- Main Render ---
  return (
    <div className="min-h-screen bg-pink-50 flex flex-col font-sans p-4 sm:p-6">
      
      {/* Header */}
      <header className="mb-6 bg-white p-4 rounded-xl shadow-lg border-b-4 border-pink-500">
        <h1 className="text-3xl font-extrabold text-pink-700 text-center">
          üßÅ K's Kupcakes Chat
        </h1>
        <p className="text-center text-sm text-gray-500 mt-1">
          Chatting with Sprinkles (Your User ID: <span className="font-mono text-xs text-pink-600 bg-pink-100 p-1 rounded">{userId || 'Loading...'}</span>)
        </p>
      </header>

      {/* Chat Area */}
      <div className="flex-grow overflow-y-auto bg-white p-4 rounded-xl shadow-inner mb-4 max-h-[70vh] border border-pink-200">
        <div className="flex flex-col">
          
          {/* Welcome Message */}
          {messages.length === 0 && (
            <div className="text-center text-gray-500 my-8">
              <span className="text-2xl">üëã</span>
              <p className="mt-2">I'm Sprinkles! Ask me anything about K's Kupcakes. What flavor are you craving today?</p>
            </div>
          )}

          {/* Render Messages */}
          {messages.map((msg) => (
            <MessageBubble key={msg.id} message={msg} />
          ))}

          {/* Loading Indicator */}
          {isLoading && (
            <div className="flex justify-start mb-4">
              <div className="bg-gray-100 text-gray-600 px-4 py-3 rounded-xl rounded-tl-none shadow-md">
                <div className="flex space-x-1">
                  <span className="animate-bounce-slow delay-0">.</span>
                  <span className="animate-bounce-slow delay-100">.</span>
                  <span className="animate-bounce-slow delay-200">.</span>
                </div>
              </div>
            </div>
          )}

          <div ref={messagesEndRef} />
        </div>
      </div>

      {/* Input Form */}
      <form onSubmit={handleSend} className="flex bg-white p-3 rounded-xl shadow-2xl border border-pink-300">
        <input
          type="text"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder={isLoading ? "Sprinkles is baking up an answer..." : "Ask Sprinkles a question..."}
          className="flex-grow p-3 border-none focus:outline-none rounded-lg text-gray-700 disabled:bg-white"
          disabled={!isAuthReady || isLoading}
        />
        <button
          type="submit"
          className="ml-3 px-6 py-3 bg-pink-600 text-white font-semibold rounded-lg shadow-lg hover:bg-pink-700 disabled:bg-pink-400 disabled:shadow-none transition-all duration-200 ease-in-out transform hover:scale-[1.02]"
          disabled={!isAuthReady || isLoading || !input.trim()}
        >
          {isLoading ? 'Sending...' : 'Send'}
        </button>
      </form>
    </div>
  );
};

export default App;
// Custom CSS for bounce animation
const style = document.createElement('style');
style.innerHTML = `
@keyframes bounce-slow {
  0%, 100% {
    transform: translateY(-25%);
    animation-timing-function: cubic-bezier(0.8, 0, 1, 1);
  }
  50% {
    transform: translateY(0);
    animation-timing-function: cubic-bezier(0, 0, 0.2, 1);
  }
}
.animate-bounce-slow {
  animation: bounce-slow 1.5s infinite;
}
.delay-100 { animation-delay: 0.1s; }
.delay-200 { animation-delay: 0.2s; }
`;
document.head.appendChild(style);
